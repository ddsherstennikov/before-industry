// клеточный автомат Ц игра Ђ∆изньї
// строка ввода в консоли им. вид: 
// a.exe ЦtX ЦhY ЦwZ <data.txt >out.txt
// где X = 0/1 Ц не тор/тор; Y Ц количество строк карты; Z Ц количество столбцов; 
//
//-------------------------------------------------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>

const char MapCellSymb  = 'i';    /* символ клетки на карте                           */
const char MapVoidSymb = '.';    /* символ пустого места на карте               */

//-------------------------------------------------------------------------------------------------------------------
// получает:     матрицу 3х3 Ц Ђокрестностьї
// возвращает: 1 Ц если центр окрестности по правилам на сл. шаге мен€етс€ и 
//                       0 Ц если остаЄтс€ как есть

int change(int m[3][3]) 
{
 int i, j, n = 0;
 int birth = 0, destr = 0;    /* событи€ Ђрождение кл.ї и Ђгибель кл.ї: */  
                                         /* да = 1, нет = 0                            */
 
 for(i=0;i<=2;i++)            /* считаем число Ђживыхї кл.     */
 for(j=0;j<=2;j++)
 n += (m[i][j] == MapCellSymb); 
 
 if(m[1][1] == MapCellSymb) n--;    /* центральную не считаем */
            
 destr = ( (m[1][1] == MapCellSymb) && ((n < 2)||(n > 3)) );    /* провер€ем */ 
 birth = ( (m[1][1] == MapVoidSymb) && (n == 3) );                /* событи€ */

 if ( (destr) || (birth) ) return 1;
 else return 0; 
}

//-------------------------------------------------------------------------------------------------------------------

int main(int argc, char* argv[])
{
 int err;                                                       /* 1, если при вводе допущена ошибка, 0 - иначе  */
 int i, j, ii, jj, I, J;                                        /* ii, jj, I, J Ц параметры дл€ цикла Ђокрестностиї */
 int h, w, t;                       
 int c;


//-------------------------------------------------------------------------------------------------------------------
// провер€ем, что в консоли были введены верные ключи и запоминаем их знач-и€

 c = argv[1][1]; if(c != 't') err=1;
 c = argv[2][1]; if(c != 'h') err=1;
 c = argv[3][1]; if(c != 'w') err=1;
 
 t = argv[1][2]-'0'; 
 h = argv[2][2]-'0';
 w = argv[3][2]-'0';
 
 if ( (t != 0) && (t != 1) ) err = 1;
 if ( (h<3) || (h > 25) ) err = 1;
 if ( (w < 3) || (w > 25) ) err = 1;

 if (err == 1) printf ("\nparameters declined.");    /* обработали пар-ры карты               */
 else {                                                                    /* если они корректны, продолжаем  */

 int L[h][w];                                                      /* исходна€ карта                           */
 int R[h][w];                                                      /* карта после одной итерации    */
 int nh[3][3] =     /* исходна€ карта Ђокрестностиї */
                        { '.', '.', '.',
                           '.', '.', '.',
                           '.', '.', '.'  };

 //------------------------------------------------------------------------------------------------------------------
 // считывание + заполнение исходной карты

 i = 0; j = 0; err = 0;

 while ( (c = fgetc(stdin)) != EOF ) 
 {
  if ( ((c == '\n') + (j == w)) == 1 ) 
      {err = 1; break;                              /* длина линии не равна w => ошибка ввода     */
  } else                          
  if (j == w) 
      {j = 0; i++;                                    /* лини€ считана корректно => переход к след. */
  } else if(i == h) 
      {err = 1; break;                             /* ввод длиннее h строк => ошибка ввода           */
  }                 

  L[i][j] = c;

  if(c != '\n') j++;                                 /* символы конца строки не считаем */
 }

 if (err) printf("\ninput does not fit your parameters.");    /* обработали карту                    */
 else {                                                                                 /* если корректна, продолжаем */
 
 //------------------------------------------------------------------------------------------------------------------
 // на основе исходной карты, строим карту следующего такта

 i=0; j=0;
 for(i=0;i<=h-1;i++)
 for(j=0;j<=w-1;j++)
 {
   
   //-----------------------------------------------------------------------------------------------------------------
   // получаем матрицу nh[3][3]
   // ( 3x3 Ђокрестностьї эл-та L[i][j] )
  
   if (t == 1) {                                             /* получаем Ђокрестностьї в случае Ђтораї */
                                                                  /* соседние стороны Ђтораї св€заны            */
       for(ii=i-1;ii<=i+1;ii++)  
       for(jj=j-1;jj<=j+1;jj++) { 
           I=ii; J=jj;
   
           if (I<0) I=h-1; else if (I>h-1) I=0;            /* проверка кра€ области */
           if (J<0) J=w-1; else if (J>w-1) J=0;
     
           nh[ii-(i-1)][jj-(j-1)] = L[I][J];
       }     
   } else if (t == 0) {                  /* получаем Ђокрестностьї в случае Ђпр€моугольникаї */
                                                 /* соседние стороны Ђпр€м-каї не св€заны                      */
       for(ii=i-1;ii<=i+1;ii++)  
       for(jj=j-1;jj<=j+1;jj++) {
           I=ii; J=jj;
 
            if ((I<0)||(I>h-1)||(J<0)||(J>w-1))                /* проверка кра€ области */
                nh[ii-(i-1)][jj-(j-1)] = MapVoidSymb;
            else
                nh[ii-(i-1)][jj-(j-1)] = L[I][J];
       }     
   }

  //-----------------------------------------------------------------------------------------------------------------
  // заносим в R[i][j] значение след. такта

  if ( change(nh) == 0 ) R[i][j] = L[i][j];                                   /* если не мен€етс€ - копируем */
  else if (L[i][j] ==  MapVoidSymb) R[i][j] = MapCellSymb; /* иначе Ц мен€ем на обратный */ 
  else if (L[i][j] == MapCellSymb) R[i][j] = MapVoidSymb;
 }

 for(i=0;i<=h-1;i++)                                      /*             вывод карты след. такта                        */
 for(j=0;j<=w-1;j++) { 
     fputc(R[i][j], stdout); 
     fputc('\n', stdout);
 }

 }}                                                                  /* (закрывающие скобки от обработки ошибок) */

 return 0;
}
//-------------------------------------------------------------------------------------------------------------------
